/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Main;

/*import AddTwoLinkedLists.AddTwoLinkedLists;
import AddTwoLinkedLists.ListNode;
import BinaryTreeRightSideView.BTRightSideView;
import BinaryTreeRightSideView.TreeNode;
import CountDigitOne.CountDigitOne;
import FlattenTree.FlattenTree;


import ReverseLinkedListII.ReverseLinkedListII;
import RotateImage.RotateImage;

import RotateList.RotateList;
import SortLinkedList.SortLinkedList;
import SpiralMatrix.SpiralMatrix;
import TwoSum.TwoSum;

import InsertionSortList.InsertionSortList;
import InsertionSortList.ListNode;
import IterativePreOrderTraversal.IterativeBinaryTreePreOrder;
import IterativePreOrderTraversal.TreeNode;
import KTermsReversal.KTermsReversal;
import KTermsReversal.ListNode;
import BTZigZagLevelOT.BTZigZagLevelOT;
import BTZigZagLevelOT.TreeNode;
import KthHighestNumber.KthHighestNumber;
import SearchForRange.SearchForRange;
import TRIE.Trie;
import InvertBinaryTree.InvertBinaryTree;
import InvertBinaryTree.TreeNode;
import JumpGame.JumpGame;
import PopNxtRightPointers.PopNxtRightPointers;
import PopNxtRightPointers.TreeLinkNode;
import MergeTwoSortedLinkedLists.ListNode;
import MergeTwoSortedLinkedLists.MergeTwoSortedLinkedLists;
import ReorderList.ReorderList;
import ReversePolishNotation.ReversePolishNotation;
import InterleavingString.InterleavingString;
import MergeKSortedLists.MergeKSortedLists;
import MinHeap.MinHeap;
import ReorderList.ListNode;
import ReorderList.ReorderList;
import MergeKSortedLists.ListNode;
import MergeKSortedLists.MergeKSortedLists;
import ValidateBinarySearchTree.TreeNode;
import ValidateBinarySearchTree.ValidateBST;
import BacktrackStringPermutation.BacktrackStringPermutation;
import ClimbingStairs.ClimbingStairs;
import SortLinkedList.ListNode;
import SortLinkedList.SortLinkedList;*/
import BTStringPermute.BTStringPermute;
import BacktrackStringPermutation.BacktrackStringPermutation;
import BasicCalculator.BasicCalculator;
import BestTimeBuySell.BestTimeBuySell;
import BestTimeBuySell2.BestTimeBuySell2;
import BinaryTreePaths.BinaryTreePaths;
import BuildTreeFromInPostOrders.BuildTreeFromInPostOrders;
import Candy.Candy;
import ClimbingStairs.ClimbingStairs;
import CombinationSum.CombinationSum;
import CombinationSumII.CombinationSumII;
import CourseSchedule.CourseSchedule;
import CourseScheduleII.CourseScheduleII;
import DecodeWays.DecodeWays;
import GasStation.GasStation;
import GroupAnagrams.GroupAnagrams;
import HIndex.HIndex;
import HouseRobber.HouseRobber;
import HouseRobberII.HouseRobberII;
import InterleavingString.InterleavingString;
import IntersectionOfLinkedLists.IntersectionOfLinkedLists;
import IterativeInorderTraversal.IterativeInorderTraversal;
import JumpGameII.JumpGameII;
import LetterCombinations.LetterCombinations;
import ListNode.ListNode;
import LongestIncreasingSubsequence.LongestIncreasingSubsequence;
import LongestValidParentheses.LongestValidParentheses;
import LowestCommonAncestorBST.LCABST;
import MajorityElement.MajorityElement;
import MaximalSquare.MaximalSquare;
import MaximumProductSubarray.MaximumProductSubarray;
import MergeIntervals.Interval;
import MergeIntervals.MergeIntervals;
import MinimumPathSum.MinimumPathSum;
import NumberOfIslands.NumberOfIslands;
import PalindromeLinkedList.PalindromeLinkedList;
import PascalsTriangle.PascalsTriangle;
import PathSum.PathSum;
import PathSumII.PathSumII;
import PerfectSquares.PerfectSquares;
import PermutationSequence.PermutationSequence;
import PermutationsII.PermutationsII;
import RemoveDuplicatesII.RemoveDuplicatesII;
import RemoveInteger.RemoveInteger;
import RemoveNthNodeFromEndOfList.RemoveNthNodeFromEnd;
import ReverseInteger.ReverseInteger;
import ReverseLinkedListBetween.ReverseLinkedListBetween;
import RotateArray.RotateArray;
import SetMatrixZeroes.SetMatrixZeroes;
import SortColors.SortColors;
import SortedArrayToBST.SortedArrayToBST;
import SortedListToBST.SortedListToBST;
import Subsets.Subsets;
import SumRootToLeafNumbers.SumRootToLeafNumbers;
import SwapNodesInPairs.SwapNodesInPairs;
import SymmetricTree.SymmetricTree;
import TreeNode.TreeNode;
import Triangle.Triangle;
import UniquePaths.UniquePaths;
import UniquePathsII.UniquePathsII;
import ValidParentheses.ValidParentheses;
import isPalindrome.IsPalindrome;
import java.io.Console;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.util.Timer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Muddassar
 */
public class MainRunner {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        
        //Count Primes
        /*int input = 1;
        Scanner reader = new Scanner(System.in);
        input = reader.nextInt();
        long time = System.currentTimeMillis();
        int result = new CountPrimes.CountPrimes().countPrimes(input);
        System.out.println(System.currentTimeMillis()-time);
        
        //System.out.println(result);
        
        try {
            System.in.read();
        } catch (IOException ex) {
            Logger.getLogger(MainRunner.class.getName()).log(Level.SEVERE, null, ex);
        }*/
        
        //Flatten Tree
        
        /*FlattenTree tree = new FlattenTree();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(5);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(4);
        root.right.right = new TreeNode(6);
        tree.flatten(root);*/
        
        //Count Digit One
        /*CountDigitOne one = new CountDigitOne();
        int value = one.countDigitOne(113);
        int value1 = one.countDigitOneBetter(113);
        System.out.println(value);
        System.out.println(value1);
        */
        
        //Reverse LinkedList II
        
        /*ReverseLinkedListII rev = new ReverseLinkedListII();
        ListNode node = new ListNode(3);
        ListNode temp = node;
        temp.next = new ListNode(5);*/
        /*temp = temp.next;
        temp.next = new ListNode(3);
        temp = temp.next;
        temp.next = new ListNode(4);
        temp = temp.next;
        temp.next = new ListNode(5);
        temp = temp.next;
        temp.next = new ListNode(6);
        temp = temp.next;
        temp.next = new ListNode(7);
        temp = temp.next;
        temp.next = new ListNode(8);
        temp = temp.next;
        temp.next = new ListNode(9);*/
        
        /*rev.print(node);
       
        rev.print(rev.reverseBetween(node, 2, 2));*/
        
       /* RegexMatching matcher = new RegexMatching();
        boolean match = matcher.isMatch("aa", "aa");
        
        System.out.println(match);
        */
        
        //Two sum problem
        /*TwoSum sum = new TwoSum();
        int[]nums = new int[]{-3,4,3,90};
        int target = 0;
        int[] result = sum.twoSum(nums, target);
        for(int k =0; k<result.length;k++)
        {
            System.out.println(result[k]);
        }*/
        
        /*//Spiral matrix
        int[][]mat = new int[3][];
        
        mat[0] = new int[]{1,2,3};
        mat[1] = new int[]{4,5,6};
        mat[2] = new int[]{7,8,9};
        
        
        SpiralMatrix matr = new SpiralMatrix();
        List<Integer> res = matr.spiralOrder(mat);
        
        for(int i=0;i<res.size();i++)
        {
            System.out.println(res.get(i));
        }*/
        
        /*ListNode node = new ListNode(1);
        node.next = new ListNode(2);
        node.next.next = new ListNode(3);
        //node.next.next.next = new ListNode(4);
        //node.next.next.next.next = new ListNode(5);
        
        RotateList list = new RotateList();
        ListNode res = list.rotateRight(node, 2000000000);
        
        while(res != null)
        {
            System.out.println(res.val);
            res = res.next;
        }
        */
        
        // BT Rightside View
        /*TreeNode node = new TreeNode(1);
        node.left = new TreeNode(2);
        //node.right = new TreeNode(3);
        node.left.right = new TreeNode(5);
        //node.right.right = new TreeNode(4);
        
        BTRightSideView btr = new BTRightSideView();
        List<Integer> rightView = btr.rightSideView(node);
        for(int i =0;i<rightView.size();i++)
        {
            System.out.println(rightView.get(i));
        }
        */
        
        //Rotate Matrix
        
        /*int[][] mat = new int[6][];
        mat[0] = new int[]{1,2,3,4,5,6};
        mat[1] = new int[]{7,8,9,10,11,12};
        mat[2] = new int[]{13,14,15,16,17,18};
        mat[3] = new int[]{19,20,21,22,23,24};
        mat[4] = new int[]{25,26,27,28,29,30};
        mat[5] = new int[]{31,32,33,34,35,36};
                */
        
        
        /*int[][] mat = new int[4][];
        mat[0] = new int[]{1,2,3,4};
        mat[1] = new int[]{5,6,7,8};
        mat[2] = new int[]{9,10,11,12};
        mat[3] = new int[]{13,14,15,16};
        
        
        RotateImage img = new RotateImage();
        
        for(int i=0;i<mat.length;i++)
        {
            for(int j=0;j<mat.length;j++)
            {
                System.out.print(mat[i][j]);
            }
            System.out.println("");
        }
        
        img.rotate(mat);
        
        for(int i=0;i<mat.length;i++)
        {
            for(int j=0;j<mat.length;j++)
            {
                System.out.print(mat[i][j]);
            }
            System.out.println("");
        }
                */
        /*SortLinkedList list = new SortLinkedList();
        ListNode node = new ListNode(1);
        node.next = new ListNode(5);
        node.next.next = new ListNode(2);
        //node.next.next.next = new ListNode(4);
        //node.next.next.next.next = new ListNode(6);
        //node.next.next.next.next.next = new ListNode(3);
        
        list.sortList(node);
        
        while(node!= null)
        {
            System.out.println(node.val);
        }*/
        
        /*AddTwoLinkedLists lts = new AddTwoLinkedLists();
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(9);
        node2.next = new ListNode(9);
        lts.addTwoNumbers(node1,node2);
        */
        
        /*ListNode node = new ListNode(2);
        node.next = new ListNode(1);
        InsertionSortList lt = new InsertionSortList();
        
        
        ListNode start = lt.insertionSortList(node);
        while(start !=null)
        {
            System.out.println(start.val);
            start = start.next;
        }*/
        
        /*TreeNode node = new TreeNode(1);
        node.right = new TreeNode(2);
        node.right.left = new TreeNode(3);
        
        IterativeBinaryTreePreOrder tv = new IterativePreOrderTraversal.IterativeBinaryTreePreOrder();
        List<Integer> result = tv.preorderTraversal(node);
        
        for(Integer i : result)
        {
            System.out.println(i);
        }*/
           
        /*ListNode node = new ListNode(1);
        node.next = new ListNode(2);
        node.next.next = new ListNode(3);
        node.next.next.next = new ListNode(4);
        node.next.next.next.next = new ListNode(5);
        node.next.next.next.next.next = new ListNode(6);
        
        KTermsReversal rev = new KTermsReversal();
        ListNode res = rev.reverseKGroup(node, 2);
        ListNode itr = res;
        while(itr!=null)
        {
            System.out.println(itr.val);
            itr = itr.next;
        }*/
        
        /*Trie trie = new Trie();
        trie.insert("ab");
        System.out.println(trie.search("a"));
        System.out.println(trie.search("ab"));
        System.out.println(trie.startsWith("a"));
        System.out.println(trie.startsWith("ab"));*/
                
        
        /*TreeNode node = new TreeNode(1);
        node.left = new TreeNode(2);
        node.right = new TreeNode(3);
        BTZigZagLevelOT btzz = new BTZigZagLevelOT();
        
        for(List<Integer> lv : btzz.zigzagLevelOrder(node))
        {
            for(int i : lv)
            {
                System.out.print(i);
            }
            System.out.println("");
        }*/
        
        /*KthHighestNumber kth = new KthHighestNumber();
        int[]nums = new int[]{99,99};
        int k = 1;
        System.out.println(kth.findKthLargest(nums, k));
                */
        /*SearchForRange sr = new SearchForRange();
        int[] nums = new int[]{1};
        int[] res = sr.searchRange(nums, 0);
        for(int i : res)
        {
            System.out.println(i);
        }*/
        
        /*TreeLinkNode nd = new TreeLinkNode(1);
        nd.left = new TreeLinkNode(2);
        nd.right = new TreeLinkNode(3);
        nd.left.left = new TreeLinkNode(4);
        nd.left.right = new TreeLinkNode(5);
        nd.right.left = new TreeLinkNode(6);
        nd.right.right = new TreeLinkNode(7);
        
        PopNxtRightPointers ptr = new PopNxtRightPointers();
        ptr.connect(nd);
        String st = "test";*/
        
        /*JumpGame gm = new JumpGame();
        int[] nums = new int[]{3,2,1,0,4};
        System.out.println(gm.canJump(nums));
                */
        
        /*TreeNode node = new TreeNode(1);
        node.left = new TreeNode(2);
        node.right = new TreeNode(3);
        node.left.left = new TreeNode(4);
        node.left.right = new TreeNode(5);
        node.right.left = new TreeNode(6);
        node.right.right = new TreeNode(7);
        
        InvertBinaryTree tr = new InvertBinaryTree();
        TreeNode n = tr.invertTree(node);*/
        
        /*ListNode node1 = new ListNode(1);
        node1.next = new ListNode(3);
        node1.next.next = new ListNode(5);
        
        ListNode node2 = new ListNode(2);
        node2.next = new ListNode(4);
        //node2.next.next = new ListNode(6); 
        
        MergeTwoSortedLinkedLists lts = new MergeTwoSortedLinkedLists();
        ListNode res = lts.mergeTwoLists(node1, node2);
        
        ListNode itr = res;
        while(itr != null)
        {
            System.out.println(itr.val);
            itr = itr.next;
        }*/
        
        /*ReversePolishNotation rpn = new ReversePolishNotation();
        String[] tokens = new String[]{"4","-2","/","2","-3","-","-"};
        int val = rpn.evalRPN(tokens);
        System.out.println(val);*/
        
        /*ReorderList lt = new ReorderList();
        ListNode node = new ListNode(1);
        node.next = new ListNode(2);
        node.next.next = new ListNode(3);
        node.next.next.next = new ListNode(4);
        node.next.next.next.next = new ListNode(5);
        node.next.next.next.next.next = new ListNode(6);
        node.next.next.next.next.next.next = new ListNode(7);
        node.next.next.next.next.next.next.next = new ListNode(8);
        
        lt.reorderList(node);
        
        ListNode itr = node;
        while(itr!=null)
        {
            System.out.println(itr.val);
            itr = itr.next;
        }*/
        
        /*InterleavingString str = new InterleavingString();
        //System.out.println(str.isInterleave("aabcc", "dbbca", "aadbbbaccc"));
        System.out.println(str.isInterleave("ab", "c", "bac"));*/
        
        /*MinHeap hp = new MinHeap(10);
        hp.add(5);
        hp.add(4);
        hp.add(3);
        hp.add(2);
        hp.add(1);
        hp.print();*/
        
        /*MergeKSortedLists lists = new MergeKSortedLists();
        
        ListNode[] lts = new ListNode[4];
        
        ListNode first = new ListNode(-8);
        first.initialize(new int[]{-7,-7,-5,1,1,3,4});
        
        ListNode second = new ListNode(-2);
        
        ListNode third = new ListNode(-10);
        third.initialize(new int[]{-10,-7,0,1,3});
        
        ListNode fourth = new ListNode(2);
        
        lts[0] = first;
        lts[1] = second;
        lts[2] = third;
        lts[3] = fourth;
        
        ListNode res = lists.mergeKLists(lts);
        res.print();*/
        
        /*TreeNode n = new TreeNode(3);
        
        n.left = new TreeNode(0);        
        n.left.right = new TreeNode(4);
        
        n.right = new TreeNode(7);
        n.right.left = new TreeNode(2);
        
        ValidateBST bst = new ValidateBST();
        System.out.println(bst.isValidBST(n));*/
        
        /*ClimbingStairs stairs = new ClimbingStairs();
        System.out.println(stairs.climbStairs(4));*/
        
        
        //Not completed
        /*SortLinkedList sort = new SortLinkedList();
        ListNode node = new ListNode(3);
        node.next = new ListNode(5);
        node.next.next = new ListNode(4);
        node.next.next.next = new ListNode(-2);
        node.next.next.next.next = new ListNode(-1);
        sort.sortList(node);*/
        
        /*BacktrackStringPermutation pm = new BacktrackStringPermutation();
        pm.backtrackStringPermute("abcd");*/
        
        /*LCABST lc = new LCABST();
        TreeNode node = new TreeNode(1);
        node.left = new TreeNode(2);
        node.right = new TreeNode(3);
        node.left.left = new TreeNode(4);
        node.left.right = new TreeNode(5);
        node.right.left = new TreeNode(6);
        node.right.right = new TreeNode(8);
        
        System.out.println(lc.dfs(node, new TreeNode(3)));*/
        
        /*SumRootToLeafNumbers srtln = new SumRootToLeafNumbers();
        TreeNode node = new TreeNode(5);
        node.left = new TreeNode(4);
        node.right = new TreeNode(8);
        node.left.left = new TreeNode(11);
        node.left.left.left = new TreeNode(7);
        node.left.left.right = new TreeNode(2);
        srtln.sumNumbers(node);
        */
        
        /*PathSumII ps2 = new PathSumII();
        
        TreeNode node = new TreeNode(5);
        node.left = new TreeNode(4);
        node.right = new TreeNode(8);
        node.left.left = new TreeNode(11);
        node.left.left.left = new TreeNode(7);
        node.left.left.right = new TreeNode(2);
        
        node.right.left = new TreeNode(13);
        node.right.right = new TreeNode(4);
        node.right.right.left = new TreeNode(5);
        node.right.right.right = new TreeNode(1);
        ps2.pathSum(node, 22);*/
        
        /*ClimbingStairs sta = new ClimbingStairs();
        System.out.println(sta.climbStairs(5));*/
        
        /*HouseRobber hr = new HouseRobber();
        //int[] nums = new int[]{7,12,7,1,5};
        int[] nums = new int[]{2,1,1,2};
        System.out.println(hr.rob(nums));*/
        
        /*HouseRobberII hr2 = new HouseRobberII();
        //int[] nums = new int[]{2,1,1,1};
        int[] nums = new int[]{2,7,9,3,1,4};
        System.out.println(hr2.rob(nums));*/
        
        
        //Still working on this
        /*MinimumPathSum minPathSum = new MinimumPathSum();
        int[][] grid = new int[3][];
        grid[0] =new int[]{1,5,5};
        grid[1] =new int[]{3,6,5};
        grid[2] =new int[]{5,1,1};*/
        /*int[][] grid = new int[2][];
        grid[0] =new int[]{2,1};
        grid[1] =new int[]{2,1};*/
        //System.out.println(minPathSum.minPathSum(grid));
        
        /*ListNode node = new ListNode(1);
        node.initialize(new int[]{2,3,4,5,6,7});
        SortedListToBST slbst = new SortedListToBST();
        TreeNode n = slbst.sortedListToBST(node);*/
        
        /*PerfectSquares ps = new PerfectSquares();
        System.out.println(ps.numSquares(12));*/
        
        /*BestTimeBuySell btbs = new BestTimeBuySell();
        System.out.println(btbs.maxProfit(new int[]{3,8,2,1,5}));*/
        
        
        /*TreeNode n = new TreeNode(1);
        n.left = new TreeNode(2);
        n.right = new TreeNode(3);
        
        n.left.left = new TreeNode(4);
        //n.left.right = new TreeNode(5);
        
        n.right.left = new TreeNode(6);
        n.right.right = new TreeNode(7);
        IterativeInorderTraversal tr = new IterativeInorderTraversal();
        
        List<Integer> res = tr.inorderTraversal(n);
        for(int i : res)
        {
            System.out.println(i);
        }*/
        
        //Backtrack subsets
        /*Subsets sb = new Subsets();
        int[] nums = new int[]{1,2,3};
        List<List<Integer>> res = sb.subsets(nums);
        
        for(List<Integer> r : res)
        {
            for(int i : r)
            {
                System.out.println(i);
            }
        }*/
        
        /*int[] nums = new int[]{1,2};
        SortedArrayToBST bst = new SortedArrayToBST();
        TreeNode n = bst.sortedArrayToBST(nums);*/
        
        /*ValidParentheses vp = new ValidParentheses();
        System.out.println(vp.isValid("([)]"));
        
        int[] res = new int[]{1,3,2,-1};
        Arrays.sort(res);
        Hashtable<String, Integer> hs = new Hashtable<>();*/
        
        /*SymmetricTree sym = new SymmetricTree();
        TreeNode n = new TreeNode(1);
        n.left = new TreeNode(2);
        n.right = new TreeNode(2);
        System.out.println(sym.isSymmetric(n));*/
        
        /*BTStringPermute per = new BTStringPermute();
        List<List<Integer>> val = per.permute(new int[]{1,2,3});
        for(List<Integer> l : val)
        {
            for(int i : l)
            {
                System.out.print(i);
            }
            System.out.println("");
        }*/
        
        /*IntersectionOfLinkedLists ioll = new IntersectionOfLinkedLists();
        ListNode one = new ListNode(1);
        one.next = new ListNode(2);
        
        
        
        ListNode two = new ListNode(6);
        two.next = new ListNode(7);
        two.next.next = new ListNode(8);
        two.next.next.next = new ListNode(9);
        two.next.next.next.next = new ListNode(10);
        two.next.next.next.next.next = new ListNode(11);
        
        ListNode common = new ListNode(3);
        common.next = new ListNode(4);
        common.next.next = new ListNode(5);
        one.next.next = common;
        two.next.next.next.next.next.next = common;*/
        /*ListNode one = new ListNode(3);
        ListNode two = new ListNode(2);
        two.next = one;
        ListNode res = ioll.getIntersectionNode(one, two);
        System.out.println(res.val);*/
       
        /*PascalsTriangle pt = new PascalsTriangle();
        List<List<Integer>> res = pt.generate(2);
        for(List<Integer> r : res)
        {
            for(int i: r)
            {
                System.out.print(i);
            }
            System.out.println("");
        }*/
        
        /*BinaryTreePaths pts = new BinaryTreePaths();
        TreeNode n = new TreeNode(1);
        n.left = new TreeNode(2);
        n.left.left = new TreeNode(4);
        n.right = new TreeNode(3);
        n.right.right = new TreeNode(7);
        List<String> res = pts.binaryTreePaths(n);
        for(String s: res)
        {
            System.out.println(s);
        }*/
           
        /*BuildTreeFromInPostOrders bt = new BuildTreeFromInPostOrders();
        int[] inorder = new int[]{1,2,3,4,5,6};
        int[] postorder = new int[]{1,5,4,3,6,2};
        TreeNode r = bt.buildTree(inorder, postorder);
        String res = "a.";
        IsPalindrome pal = new IsPalindrome();
        System.out.println(pal.isPalindrome(res));*/
        
        //Not completed
        /*ReverseLinkedListBetween bt = new ReverseLinkedListBetween();
        ListNode node = new ListNode(1);
        node.initialize(new int[]{2});
        ListNode res = bt.reverseBetween(node, 2, 2);
        bt.print(res);*/
        
        /*ReverseInteger rev = new ReverseInteger();
        System.out.println(rev.reverse(1534236469));*/
        
        //Not done
        /*RemoveInteger it = new RemoveInteger();
        int[] ip = new int[]{1};
        it.removeElement(ip, 1);*/
        
        /*PermutationsII pr2 = new PermutationsII();
        int[] nums = new int[]{1,1,2};
        List<List<Integer>> result = pr2.permuteUnique(nums);
        for(List<Integer> r: result)
        {
            for(int i: r)
            {
                System.out.print(i);
            }
            System.out.println("");
        }*/
        
        /*NumberOfIslands isl = new NumberOfIslands();
        char[][]grid = new char[1][2];*/
        
        /*for(int k=0;k<4;k++)
        {
            for(int l=0;l<5;l++)
            {
                grid[k][l]='0';
            }
        }*/
        /*for(int i=0;i<4;i++)
        {
            grid[0][i] = '1';
        }
        for(int i=0;i<2;i++)
        {
            grid[1][i] = '1';
        }
        for(int i=0;i<2;i++)
        {
            grid[2][i] = '1';
        }
        grid[0][3]='1';*/
        
        /*for(int i=0;i<2;i++)
        {
            grid[0][i] = '1';
            grid[1][i] = '1';
            grid[3][4-i] = '1';
        }
        grid[2][2]='1';*/
        //System.out.println(isl.numIslands(grid));
        
        /*SetMatrixZeroes mtz = new SetMatrixZeroes();
        int[][] matrix = new int[5][4];
        for(int j=0;j<3;j++)
        {
            matrix[0][j] = 0;
            matrix[2][j] = 0;
            matrix[4][j] = 0;
        }
        matrix[0][3]=5;
        matrix[1][3]=4;
        matrix[2][3]=4;
        matrix[3][3]=3;
        matrix[4][3]=1;
        
        
        
        mtz.setZeroes(matrix);*/
        
        /*BestTimeBuySell2 bs2 = new BestTimeBuySell2();
        int[] prices = new int[]{2,1};
        bs2.maxProfit(prices);*/
        
        /*GasStation gs = new GasStation();
        int[] gas = new int[]{2,3,1};
        int[] cost = new int[]{3,1,2};
        System.out.println(gs.canCompleteCircuit(gas, cost));*/
        
        /*DecodeWays dw = new DecodeWays();
        System.out.println(dw.numDecodings("01"));*/
        
        /*LongestIncreasingSubsequence lis = new LongestIncreasingSubsequence();
        int[] nums = new int[]{10,9,2,5,3,4};
        System.out.println(lis.lengthOfLIS(nums));*/
        
        /*RotateArray arr = new RotateArray();
        int[] nums = new int[]{1,2};
        int k = 1;
        arr.rotate(nums, k);*/
        
        /*SwapNodesInPairs snip = new SwapNodesInPairs();
        ListNode node = new ListNode(1);
        node.next = new ListNode(2);
        node.next.next = new ListNode(3);
        node.next.next.next = new ListNode(4);
        node.next.next.next.next = new ListNode(5);
        ListNode res = snip.swapPairs(node);*/
        
        /*SortedListToBST slbst = new SortedListToBST();
        ListNode node = new ListNode(1);
        node.next = new ListNode(2);
        node.next.next = new ListNode(3);
        node.next.next.next = new ListNode(4);
        node.next.next.next.next = new ListNode(5);
        TreeNode root = slbst.sortedListToBST(node);*/
        
        /*List<List<Integer>> triangle = new ArrayList<List<Integer>>();
        List<Integer> first = new ArrayList<Integer>();
        first.add(2);
        List<Integer> second = new ArrayList<Integer>();
        second.add(3);
        second.add(4);
        List<Integer> third = new ArrayList<Integer>();
        third.add(6);
        third.add(5);
        third.add(7);
        List<Integer> fourth = new ArrayList<Integer>();
        fourth.add(4);
        fourth.add(1);
        fourth.add(8);
        fourth.add(3);
        Triangle tr = new Triangle();
        triangle.add(first);
        triangle.add(second);
        triangle.add(third);
        triangle.add(fourth);
        System.out.println(tr.minimumTotal(triangle));*/
        
        //PathSum sum = new PathSum();
        //TreeNode node = new TreeNode(1);
        //node.left = new TreeNode(2);
        /*TreeNode node = new TreeNode(5);
        node.left = new TreeNode(4);
        node.right = new TreeNode(8);
        node.left.left = new TreeNode(11);
        node.left.left.left = new TreeNode(7);
        node.left.left.right = new TreeNode(2);
        node.right = new TreeNode(8);
        node.right.left = new TreeNode(13);
        node.right.right = new TreeNode(4);
        node.right.right.right = new TreeNode(1);*/
        //System.out.println(sum.hasPathSum(node, 1));
        
        /*RemoveDuplicatesII rm2 = new RemoveDuplicatesII();
        int[] nums = new int[]{1,1};
        System.out.println(rm2.removeDuplicates(nums));*/
        
        /*UniquePaths ups = new UniquePaths();
        System.out.println(ups.uniquePaths(1, 1));*/
        
        /*UniquePathsII ups2 = new UniquePathsII();
        int[][] obstacleGrid = new int[2][1];
        obstacleGrid[0][0] = 1;
        //obstacleGrid[0][1] = 1;
        //obstacleGrid[1][0] = 1;
        System.out.println(ups2.uniquePathsWithObstacles(obstacleGrid));*/
        
       /* MaximalSquare ms = new MaximalSquare();
        char[][] a = new char[4][5];
        a[0][0] = 1;
        a[0][2] = 1;
        a[1][0] = 1;
        
        ms.maximalSquare(a);*/
        
        
        /*MinimumPathSum mps = new MinimumPathSum();
        int[][]grid = new int[2][1];
        grid[0][0] = 1;
        grid[1][0] = 2;*/
        /*for(int i = 0;i<grid.length;i++)
        {
            for(int j = 0;j<grid[0].length;j++)
            {
                grid[i][j] = i*3 +j +1;
            }
        }*/
        //int val = mps.minPathSum(grid);
        
        /*MaximumProductSubarray mpsa = new MaximumProductSubarray();
        int[] nums = new int[]{2,3,-2,4};
        System.out.println(mpsa.maxProduct(nums));*/
        
        //LongestValidParentheses lvp = new LongestValidParentheses();
        //System.out.println(lvp.longestValidParentheses("(()"));
        
        /*JumpGameII jp2 = new JumpGameII();
        int[] nums = new int[]{2,3,0,1,4};
        System.out.println(jp2.jump(nums));*/
        
        /*Candy candy = new Candy();
        int[] ratings = new int[]{1,4,3,2,7};
        System.out.println(candy.candy(ratings));*/
        
        /*RemoveNthNodeFromEnd rmnth = new RemoveNthNodeFromEnd();
        ListNode node = new ListNode(1);
        node.initialize(new int[]{2});
        node.print();
        ListNode res = rmnth.removeNthFromEnd(node, 1);
        res.print();*/
        
        /*MergeIntervals mgint = new MergeIntervals();
        List<Interval> intervals = new ArrayList<Interval>();
        intervals.add(new Interval(1,4));
        intervals.add(new Interval(0,0));
        intervals.add(new Interval(1,4));
        intervals.add(new Interval(0,1));
        intervals.add(new Interval(1,4));
        intervals.add(new Interval(0,2));
        intervals.add(new Interval(3,5));
        //intervals.add(new Interval(7,10));
        //intervals.add(new Interval(15,18));
        List<Interval> result = mgint.merge(intervals);
        for(Interval i : result)
        {
            System.out.println(i.start + "," + i.end);
        }*/
        
        //CourseSchedule cs = new CourseSchedule();
        /*int numCourses = 4;
        int[][]prerequisites = new int[4][];
        prerequisites[0] = new int[]{1,0};
        prerequisites[1] = new int[]{2,0};
        prerequisites[2] = new int[]{3,1};
        prerequisites[3] = new int[]{3,2};
        //System.out.println(cs.findOrder(numCourses, prerequisites));
        
        CourseScheduleII cs2 = new CourseScheduleII();
        for(int i : cs2.findOrder(numCourses, prerequisites))
        {
            System.out.print(i);
        }*/
        
        
        
        /*MajorityElement me = new MajorityElement();
        int[] nums = new int[]{2,1,3,1,1};
        System.out.println(me.majorityElement(nums));*/
        
        /*HIndex hindex = new HIndex();
        int[] citations = new int[]{};
        System.out.println(hindex.hIndex(citations));*/
        
        /*PalindromeLinkedList plList = new PalindromeLinkedList();
        ListNode listNode = new ListNode(1);
        listNode.initialize(new int[]{2,3,3,1});
        System.out.println(plList.isPalindrome(listNode));*/
        
        /*GroupAnagrams ga = new GroupAnagrams();
        String[] strs = new String[]{"eat", "tea", "tan", "ate", "nat", "bat"};
        
        for(List<String> stc : ga.groupAnagrams(strs))
        {
            for(String s : stc)
            {
                System.out.print(s + ",");
            }
            System.out.println("");
        }
        System.out.println("done");*/
        
        /*LetterCombinations lc = new LetterCombinations();
        for(String s : lc.letterCombinations(""))
        {
            System.out.println(s);
        }*/
        
        /*PermutationSequence ps = new PermutationSequence();
        ps.getPermutation(5, 100);*/
        
        /*PermutationsII p2 = new PermutationsII();
        int[] nums = new int[]{1,1,2,2};
        List<List<Integer>> res = p2.permuteUnique(nums);
        
        for(List<Integer> l : res)
        {
            for(int i : l)
            {
                System.out.print(i);
            }
            System.out.println("");
        }*/
        
        /*CombinationSum cs = new CombinationSum();
        int[] candidates = new int[]{1,2};
        int target = 4;
        List<List<Integer>> result = cs.combinationSum(candidates, target);*/
        /*CombinationSumII cs2 = new CombinationSumII();
        int[] candidates = new int[]{1,1};
        int target = 1;
        List<List<Integer>> result = cs2.combinationSum2(candidates, target);
        
        for(List<Integer> l : result)
        {
            for(int i : l)
            {
                System.out.print(i + ",");
            }
            System.out.println("");
        }*/
        
        //InterleavingString intString = new InterleavingString();
        //System.out.println(intString.isInterleave("aabc", "abad", "aabadabc"));
        
        /*PermutationsII pm2 = new PermutationsII();
        int[] nums = new int[]{0,1,0,0,9};
        List<List<Integer>> result = pm2.permuteUnique(nums);*/
        
        
        /*Subsets sts = new Subsets();
        int[] nums = new int[]{};
        List<List<Integer>> result = sts.subsets(nums);
        
        System.out.println(result.size());
        for(List<Integer> l : result)
        {
            for(int i : l)
            {
                System.out.print(i + ",");
            }
            System.out.println("");
        }*/
        
        /*SortColors sortColors = new SortColors();
        int[] nums = new int[]{2,1,1,1,1,1};
        sortColors.sortColors(nums);
        
        for(int i : nums)
        {
            System.out.print(i);
        }*/
        
        BasicCalculator basicCalc = new BasicCalculator();
        String input = " 2-1 + 2 ";
        System.out.println(basicCalc.calculate(input));
        
        System.out.println("done");
        String ste = "ste";
        try {
            System.in.read();
        } catch (IOException ex) {
            Logger.getLogger(MainRunner.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }
    
}
